## 泛型 \<T>

### 泛型定义

泛型（Generics）是一种编程语言特性，允许在定义函数、类、接口等时使用占位符来表示类型，而不是具体的类型，等到使用时再指定类型以实现灵活的类型检查

```ts
// 1. 泛型函数
function print(arg: string): string {
  return arg;
}
function print(arg: number): number {
  return arg;
}

function print<T>(arg: T): T {
  return arg;
}

// 2. 泛型接口
interface Pair<T, U> {
  first: T;
  second: U;
}

let pair: Pair<string, number> = { first: "hello", second: 42 };
console.log(pair); // { first: 'hello', second: 42 }

interface IValue {
  <T>(arg: T): T;
}

let printFn: IValue = (arg) => arg;

// 3. 泛型类
class Box<T> {
  private value: T;

  constructor(value: T) {
    this.value = value;
  }

  getValue(): T {
    return this.value;
  }
}

let stringBox = new Box<string>("TypeScript");
console.log(stringBox.getValue()); // TypeScript
```

### 泛型约束 extends

用于限制泛型的类型范围，必须至少满足条件

```ts
interface Lengthwise {
  length: number;
}

// T 必须实现 Lengthwise 接口
function logLength<T extends Lengthwise>(arg: T): void {
  console.log(arg.length);
}

logLength("hello"); // 5
logLength(42); // Argument of type 'number' is not assignable to parameter of type 'Lengthwise'.
```

### 泛型默认值 =

当 ​​ 无法推断类型 ​​ 或 ​​ 未显式指定类型 ​​ 时，T 为默认类型

泛型默认值是一个 ​​ 后备机制 ​​，不是强制约束

```ts
function defaultValue<T = string>(arg: T): T {
  return arg;
}

let result1 = defaultValue("hello"); // 推断为 string 类型
let result2 = defaultValue(42); // 推断为 number 类型
```

## 泛型推断

泛型的类型推断遵循以下顺序:

显式指定类型 > 上下文推断（例如：传入的参数的类型）> 默认类型

## 例题

1. 函数声明的返回值类型与实现的返回值类型不一致

```ts
type User = {
  id: number;
  kind: string;
};
function makeCustomer<T extends User>(u: T): T {
  return {
    // return 报错
    id: u.id,
    kind: "customer",
  };
}

makeCustomer({ id: 1, kind: "adin", name: "jack" });

// Type '{ id: number; kind: string; name: string; }' is not assignable to type 'T'.
//  'T' could be instantiated with an arbitrary type which could be unrelated to '{ id: number; kind: string; name: string; }'.
```

```
泛型 T 是 User 的子类，它至少包含成员 id 和 kind，而函数实现的返回值类型为 { id: number, kind: string }，两者并不匹配。return处的报错与后续的函数调用无关，即使将函数调用注释掉也不会改变报错提示
```

```ts
//法一：使用展开运算符...确保类型匹配
type User = {
  id: number;
  kind: string;
};
function makeCustomer<T extends User>(u: T): T {
  return {
    ...u,
  };
}

//法二：使用类型断言强制类型一致
type User = {
  id: number;
  kind: string;
};
function makeCustomer<T extends User>(u: T): T {
  return {
    id: u.id,
    kind: "customer",
  } as T;
}
```
